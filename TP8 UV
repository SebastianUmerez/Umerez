#include <stdio.h>
#include <stdlib.h>
#define TAM 20

// Prototipos dados en el enunciado
int cuantas_piezas(int);
int rectificable(float, float);
int rechazada(float, float);
void cargar_piezas(float *, int);
int contar(int (*)(float, float), float, float *, int);
float* reservar_memoria(int);
void segregar(int (*)(float, float), float, float *, int, float *);
void mostrar_piezas(char *, float *, int);

// Función principal
int main(void) {

    float diametros[TAM] = {0};
    int n;
    float max = 12;
    float min = 10;

    n = cuantas_piezas(TAM);
    cargar_piezas(diametros, n);

    int n_rectificar = contar(rectificable, max, diametros, n);
    float *p_rectificables = reservar_memoria(n_rectificar);
    segregar(rectificable, max, diametros, n, p_rectificables);

    int n_rechazar = contar(rechazada, min, diametros, n);
    float *p_rechazadas = reservar_memoria(n_rechazar);
    segregar(rechazada, min, diametros, n, p_rechazadas);

    mostrar_piezas("\n rectificables", p_rectificables, n_rectificar);
    mostrar_piezas("\n rechazadas", p_rechazadas, n_rechazar);

    // Liberamos memoria dinámica antes de finalizar
    free(p_rectificables);
    free(p_rechazadas);

    return 0;
}

// FUNCIONES BASE
int cuantas_piezas(int max) {
    int n;
    do {
        printf("Cuántas piezas ingresará? ");
        scanf("%d", &n);
    } while (n < 0 || n > max);
    return n;
}

// Devuelve 1 si el diámetro es mayor al valor dado (rectificable)
int rectificable(float diametro, float valor) {
    if (diametro > valor) return 1;
    else return 0;
}

// Devuelve 1 si el diámetro es menor al valor dado (rechazada)
int rechazada(float diametro, float valor) {
    if (diametro < valor) return 1;
    else return 0;
}

//a) cargar_piezas
void cargar_piezas(float *p, int n) {
    float valor;
    for (int i = 0; i < n; i++) {
        do {
            printf("Ingrese diámetro de pieza %d: ", i);
            scanf("%f", &valor);
            if (valor <= 0) printf("Error \n");
        } while (valor <= 0);

        *(p + i) = valor; // Guardamos el valor en la posición i del arreglo
    }
}

//b) contar
int contar(int (*criterio)(float, float), float valor, float *p, int n) {
    int contador = 0;
    // Recorremos todas las piezas
    for (int i = 0; i < n; i++) {
        // Si la función criterio devuelve 1, incrementa el contador
        if (criterio(*(p + i), valor) == 1) contador++;
    }
    return contador; // Retorna la cantidad total que cumple el criterio
}

//c) reservar_memoria
float *reservar_memoria(int n) {
    float *ptr = (float *) malloc(n * sizeof(float));
    return ptr; // Devuelve el puntero al bloque de memoria reservado
}

//d) segregar
void segregar
(int (*criterio)(float, float), float valor, float *p, int n, float *q) {
    int j = 0; // índice para el arreglo destino
    for (int i = 0; i < n; i++) {
        if (criterio(*(p + i), valor) == 1) {
            *(q + j) = *(p + i); // copia el valor que cumple el criterio
            j++;
        }
    }
}

//e) mostrar_piezas
void mostrar_piezas(char *mensaje, float *p, int n) {
    printf("%s\n", mensaje);
    for (int i = 0; i < n; i++) {
        printf("Diámetro: %.2f\n", *(p+i));
    }
}

